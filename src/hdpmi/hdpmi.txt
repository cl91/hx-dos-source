//////////////////////////////////////////////////////////////////////////////
/                                                                            /
/               HDPMI - DPMI Server (Version 3.16)                           /
/                                                                            /
//////////////////////////////////////////////////////////////////////////////

 0. Contents

   1.    About HDPMI
   2.    Requirements
   3.    Commandline Options
   4.    Environment Settings
   5.    Returncodes and Messages
   6.    Implementation Details
    6.1  Memory Management
    6.2  Interrupts
    6.3  Exceptions
    6.4  Stacks
    6.5  Client Initialization/Termination
    6.6  DPMI API
    6.7  VDS API
    6.8  DOS API Translation
    6.9  Other API Translation Support
    6.10 Debug Support
    6.11 Nested Execution of DPMI Clients
    6.12 Other Features of HDPMI
   7.    Restrictions of current Version
   8.    Known Problems/Hints
   9.    Compatibility List
  10.    History
  11.    Copyright


 1. About HDPMI

   HDPMI is a DPMI server which conforms to DPMI specification v0.9, but
   supports a large subset of DPMI v1.0 as well. Although it is part of
   the HX runtime, it doesn't depend on any other runtime modules and can
   be used as a standalone host.

   HDPMI exists in two versions called HDPMI16.EXE and HDPMI32.EXE. The
   first will run 16-bit DPMI clients, the latter executes 32-Bit DPMI
   clients. The HX PE binary loader DPMILD32 is aware of HDPMI and will
   try to load it silently in the background if no DPMI server is found
   in memory yet.

   A DPMI server's purpose is to run applications in protected-mode. This
   gives the following benefits compared to real-mode DOS:

   þ breaks the DOS 640 kB (conventional) memory limitation. The 80386 
     supports 4 GB memory.
   þ extends the 16-bit segment limit to 32-bit, which allows to forget
     about segmented memory models and use the simple "flat" model.
   þ several privilege levels which allows "user" and "system" code.
   þ paging.
   þ memory and I/O protection.
   þ additional exceptions.

   The DPMI server will have to manage all resources specific to protected
   mode (GDT, IDT, LDT, TSS, page tables, extended memory, ...). To make
   DOS and BIOS accessible it also has to provide the ability to switch
   between modes. That's why a DPMI server has to run at a high privilege
   level and cannot be launched in a "DOS box".

   Extended features of a DPMI server are:

   þ real-mode interrupt translation services, thus allowing the client
     to use DOS Int 21h calls which use pointers, for example. HDPMI
     has such services implemented, see below.
   þ Swapfile to increase available memory by hard disk space (virtual
     memory). HDPMI does not implement a swapfile on its own, but since
     version 3.03 it is possible for the client to do this.
   þ "virtual machines". This is not supported, but optionally HDPMI allows
     to run clients in their own address contexts. Conventional memory
     (address space 0-10FFFFh) always is shared, though.


 2. Requirements

   HDPMI requires the following resources to run:

   þ a 80386 or better cpu. If environment switch HDPMI=1 is used, at least
     a 80486 is required (see below).

   þ a minimum of 72 kB of extended memory for host initialization.
     By (optionally) adding conventional DOS memory to the page pool,
     HDPMI may run without any extended memory at all.

   þ MS-DOS (version >= 3.3). FreeDOS or DR-DOS (version >= 5.0) should work
     as well.
   
   þ a XMS host if HDPMI cannot run in "raw" mode due to an unknown
     A20 gate switch mechanism.


 3. Commandline Options

   HDPMI accepts the following commandline options:

     -a: run clients in separate address contexts. This is similar to
         environment switch HDPMI=32.
     -b: keep the TLB only when at least 1 client is running. This
         option is useful only in conjunction with -r and will result
         in conventional memory usage of just 5 kB when HDPMI is idle. But
         be aware that this constellation may not work with all clients!
     -d: disable the last installed instance of HDPMI
     -e: reenable a disabled instance of HDPMI
     -h: display HDPMI help screen. It will not install as TSR.
     -i: watch direct access to the IVT to ensure hardware interrupts are
         always routed to protected mode. This is similar to environment
         switch HDPMI=1.
     -k: if a register dump is to be displayed, make sure that the screen
         is in text mode. Versions prior to 3.13 did this in any case.
     -l: TLB will be allocated in low DOS memory. Useful if DOS UMBs
         are slow or not accessible by DMA.
     -m: disables support for DPMI 1.0 memory functions (AX >= 0504h).
     -n: report clients a smaller amount of free physical pages. This is
         necessary for clients which assume this amount is safe to use.
     -r: this will cause HDPMI to install permanently as a TSR. In this
         mode HDPMI will run until it is deinstalled using option -u.
         If option -r is *not* entered, HDPMI will install as a TSR as 
         well, but will terminate when the next client has terminated (*).
     -s: 'safe' mode. Prevents client from modifying system tables. This
         is similar to environment switch HDPMI=4096.
     -t: don't touch NE bit in CR0. Without this option HDPMI will set
         the NE bit so floating point errors will cause an exception 0x10.
         Similar to environment switch HDPMI=32768.
     -u: this switch will uninstall a running instance of HDPMI.
     -v: if both XMS and VCPI hosts were detected, use VCPI memory allocation
         and ignore XMS host. 
     -y: use extended memory not managed by XMS host. Usually a "modern"
         XMS host can handle all extended memory, but old ones may handle
         63 or 255 MB only. Then setting this option may be useful. For
         XMS V3 hosts the implementation of function AH=89h must return
         in ECX the true highest physical address managed by the host. 
         This value is sometimes wrong, in which case this option shouldn't
         be set (some security checks are implemented, but it isn't
         fool-proved). If in doubt run tool DPMI.EXE to see if the value
         is reasonable.
   
   (*) Please note: Since HDPMI modifies some real mode interrupt vectors,
       it cannot terminate if any other application (it needn't be a
       protected mode app, a simple DOS TSR may suffice) has modified these
       vectors while HDPMI is running. In this case HDPMI has to remain
       resident in any case, regardless if a client is running or not.
       
   (*) It is possible to install both HDPMI16 and HDPMI32 permanently, but 
       for this to work it is required that HDPMI16 is installed first.
       Installing HDPMI16 permanently is the only way to run 16bit clients
       while HDPMI32 is loaded. The hosts will share one TLB, so both hosts
       will consume just about 20 kB conventional DOS memory.


 4. Environment Settings

   On startup HDPMI will search for environment variable "HDPMI". By setting
   this variable one may modify HDPMI's behavior. It is interpreted as bit
   values, so one may set any combination of the following values:

   HDPMI=1:  this option makes the host aware of direct IVT access
             (read/writes to linear address range 0-3FFh) in protected mode.
             Thus it can ensure that IRQs are always handled in protected mode 
             first. If the option is set, opcode INVLPG is used, which is
             implemented on 80486 or better cpus only. Same effect as
             command line option -i.
   HDPMI=2:  DOS memory is included in standard memory page pool.
             This option should be set only on machines with very
             little physical ram.
   HDPMI=4:  return 1.00 as DPMI server version. Some clients will
             refuse to work if server identifies itself as V0.90 only.
             Since HDPMI implements many DPMI V1.0 functions, such apps may
             work with this switch set.
   HDPMI=8:  allocate TLB in low DOS memory. Same effect as command line
             option -l.
   HDPMI=16: prevents HDPMI from trying to allocate a temporary 64 kB TLB
             for DOS read/write functions which exceed the static TLB size.
   HDPMI=32: run clients in separate address contexts. This option may be
             needed to allow nested execution of clients which cannot share
             an address space. The conventional memory region 0-10FFFFh
             is still shared, though. Furthermore, setting this switch will
             increase the client's DOS memory consumtion, since most parts
             of the host's DOS memory usage must then be client specific.
             Same effect as command line option -a.
   HDPMI=64: don't use XMS v3+ functions. This should make HDPMI compatible
             with XMS hookers which aren't aware of XMS v3 (WSWAP.EXE). It
             will also restrict the amount of free memory the host reports.
   HDPMI=128: disable DOS API translation for LFN functions.
   HDPMI=256: when running as VCPI client, ensure that PTEs for HMA region
             (address space 100000h-10FFFFh) are set so that physical
             addresses match linear addresses. This may not work with all
             VCPI hosts.
   HDPMI=512: alloc IDT and LDT in client address space. Usually these 
             tables are allocated in HDPMI's reserved space above linear
             address FF800000h, but some programs seem to not expect them
             at such high addresses. Furthermore, GDT is not moved to
             extended memory if this switch is on.
   HDPMI=1024: disables support for DPMI 1.0 memory functions (AX >= 0504h).
             Same effect as command line option -m.
   HDPMI=2048: clear HiWord of ESI and EDI on initial switch to protected
             mode. This doesn't conform to the DPMI specs, but is required
             to make HDPMI compatible with Borlands's 32RTM.EXE when running
             on some versions of DOS.
   HDPMI=4096: 'safe' mode. Don't allow client to write to GDT, IDT and LDT.
   HDPMI=8192: stop in debugger after client's initial switch to protected
             mode.
   HDPMI=16384: causes HDPMI to not respond to int 2Fh, ax=160Ah. This allows
             to start Windows 3.1 WIN.COM while HDPMI is loaded resident.
   HDPMI=32768: prevents HDPMI from modifying CR0 NE bit. Same effect as
             command line option -t.


 5. Returncodes and Messages

   If HDPMI is launched by a program, it will return with the following codes:

   rc   meaning
   ------------------------------------------------
   00   HDPMI is resident now in Int15 mode
   01   HDPMI is resident now in XMS mode
   02   HDPMI is resident now in VCPI mode
   03   DPMI server detected without VCPI support, HDPMI has terminated
        without taking over control. This state should be no error for
        the application since the DPMI API is available
   04   error: not enough memory for host initialization
   05   error: A20 cannot be enabled
   06   error: VCPI host has remapped IRQs
   07   error: CPU in V86 mode, but no VCPI or DPMI host found
   08   error: DOS version isn't 3.3 or higher
   09   error: CPU not 80386 or better
   0A   error: invalid command line given

   If HDPMI is started with a nonempty command line, it may display 
   messages. These are:

   - "HDPMI already installed": may occur when starting HDPMI with 
     option "-r".
   - "HDPMI not installed or disabled": may occur when starting HDPMI with 
     option "-u". 
   - "HDPMI is busy": may occur when starting HDPMI with option "-u". 
     Reason: The server has at least 1 client running.
   - "HDPMI *not* uninstalled because real-mode interrupts were modified"
     may occur when starting HDPMI with option "-u". Reason: Another TSR
     has modified an interrupt which HDPMI is using as well, so it cannot
     restore the old value. Most likely this is interrupt 2Fh.
   - "no disabled instance of HDPMI found": may occur when starting HDPMI
     with option "-e". 


 6. Implementation Details


 6.1 Memory Management

   a) Overview

     The memory usage of HDMI depends on the configuration found
     at startup. Possible configurations are:

     þ Int15 or "Raw" mode: CPU is in real-mode and no XMS host
       (HIMEM.SYS) has been found.

     þ XMS-Mode: CPU is in real-mode and a XMS host is running.

     þ VCPI-Mode: CPU is in v86-mode and a VCPI host has been detected.

     þ CPU is in v86-mode and no VCPI host has been found. HDPMI cannot
       enter ring 0 protected-mode and terminates without further message.


   b) Physical Memory Allocation

   Int15-Mode:  HDPMI allocates all of extended Memory by calling
                Int15, AX=E801h or, if this fails, by calling Int15, AH=88h. 
                When a real mode app is launched, half of currently unused
                extended memory is released. This is to allow
                nested execution of protected mode apps in this mode.
                When the launched app terminates, HDPMI graps this memory
                again.

   XMS-Mode:    Memory is allocated dynamically from the XMS host. HDPMI 
                will detect and use XMS v3 hosts, which may allow to alloc
                up to 4 GB of physical memory. The memory blocks allocated 
                are released when HDPMI terminates. If HDPMI has been
                installed permanently with option -r, the blocks (except
                the first one) are released when the server enters idle state,
                that is, no client is running.

   VCPI-Mode:   If a XMS-Host is available in this mode, HDPMI prefers to 
                allocate memory through this host, because some VCPI host's
                memory allocation API is pretty slow. So this API will be 
                used only if no XMS host is found (which should be a very
                rare constellation) or cmdline option -v has been entered.

   If all extended memory has been allocated, HDPMI will try to use
   conventional memory if environment variable HDPMI=2 is set. So in tight
   memory conditions DOS memory may be a full part of HDPMI's memory pool.
   This is optional because there is a chance that this behavior may cause
   problems (some clients simply allocate the largest available memory block
   as reported by the host, which will then make HDPMI to alloc all free DOS
   memory).

   c) Address Space Management

   Paging will always be enabled with HDPMI. It reserves the last 8 MB of
   the address space for its usage (GDT, IDT, LDT, page tables, host code).
   The rest is left for the client, so 4088 MB address space is available 
   in the range 0 - FF7FFFFFh. Optionally HDPMI can be instructed to locate
   IDT and LDT in the client address space (see environment variable HDPMI).

   d) Virtual Memory

   HDPMI itself doesn't create a swap file. But support for "exception
   restartability" has been implemented in version 3.03. This allows a
   client to catch page faults occuring inside the host, which makes it
   possible to support swapfiles (or memory-mapped files) on the client
   level.

   e) Conventional Memory

   Conventional memory (address space 0-10FFFFh) is under control of DOS.
   In XMS and raw mode HDPMI will initialize the page table for this region
   so that physical memory addresses and linear memory addresses are identical. 
   For its API translation HDPMI will use a DOS memory block of 8 kB.
   Additionally some host code has to be run in real/v86-mode, and a 2 kB
   host stack also is located in conventional memory to make it accessible
   for both modes. All in all HDPMI will use about 13 kB of DOS memory.


 6.2 Interrupts

   According to DPMI docs a host must ensure that hardware interrupts (IRQs) 
   are routed to protected mode if they have occured in real/v86-mode.
   HDPMI fullfills this requirement, for this it intercepts the real-mode
   IVT vectors of all IRQs. Routing the IRQs to protected mode, however,
   is done only if a client has changed the protected-mode interrupt vector.

   There exist some DPMI clients which get in the way, however. Most 
   likely this is because some hosts had difficulties with the IRQ
   routing to protected-mode. So these clients try to do this routing
   on their own - which may cause problems with HDPMI. For this reason,
   HDPMI has an option to catch all direct accesses to the IVT in protected
   mode (this feature is activated by setting environment variable HDPMI=1
   or command line option -i). This will slow down any access to page 0,
   however, so it should be set only if it becomes obvious that the client
   will need it to run.

   Besides the hardware interrupts there are 3 software interrupts which
   will be routed to protected-mode as well: Int 1Ch, Int 23h and Int 24h.


 6.3 Exceptions

   If an exception occurs and the client hasn't installed an exception
   handler (or if it decides to not handle the exception), HDPMI's default
   exception handler will get the exception and will do:

   Exc    Action
   ----------------------------------------------------------------
   00-05  exception is routed to protected-mode INT 00-05.
   06     client is terminated.
   07     exception is routed to protected-mode INT 07.
   08-0E  client is terminated.
   10-11  client is terminated.

   The default handler for protected-mode interrupts 00-07 will do:

   Int    Action
   ----------------------------------------------------------------
   00     client is terminated.
   01-04  interrupt is routed to real-mode.
   05     interrupt is routed to real-mode if it is a programmed INT, else
          client is terminated.
   06     interrupt is routed to real-mode.
   07     client is terminated.

   In other words, exceptions 00 and 05-07 will not arrive in real-mode.
   This is not what DPMI docs are telling, but it wouldn't make sense,
   since these exceptions are faults and the exception cause must be cured
   to continue execution. This can't be done by a real-mode interrupt handler.

   If a client is terminated, a register dump is displayed and HDPMI will
   ask whether to terminate the client or the server. The first option
   will execute an int 21h, ax=4CFFh in ring 3 protected mode, which gives
   the client a chance to clean up things. This usually works better than 
   trying to terminate the server, which may result in DOS memory blocks
   not being freed and/or IVT vectors not being restored.


 6.4 Stacks

   When a client is running the host will switch among 4 stacks:

   þ the protected mode stack (PMS), which is the stack the DPMI
     client uses. It can switch these stacks as it likes and there
     are no special requirements about it.

   þ the locked protected mode stack (LPMS). The DPMI host switches
     the client application to this stack when
     - a hardware interrupt (IRQ) has occured
     - an interrupt is reflected from real mode (mostly IRQs, but
       also software interrupts 1Ch, 23h and 24h.
     - the DPMI client executes a real mode callback
     - the server notifies the client about an exception
     There exists 1 LPMS only and its size must be at least 4 KB.
     Once it is "in use" the host will no longer switch stacks until
     the LPMS is free again.

   þ the real mode stack (RMS). Usually this stack is located in the
     memory block the DPMI client has to deliver to the server on its
     initial switch to protected mode. This stack's size will be at
     least 200h bytes. It is used when there is a reflection from protected
     mode interrupts to real mode. If protected-mode is reentered (by a
     real-mode callback, a raw jump or a hardware IRQ), the RMS is in use
     and HDPMI will then use the real mode SS:SP of the last entry to
     protected mode as current real-mode stack.

   þ the ring 0 stack. This stack is invisible to the client, it is
     used by the dpmi host. For HDPMI this stack is 2 kB in size, and
     it is located in conventional memory. The host uses this stack
     for it's normal processing and to save the client's segment register
     values.


 6.5 Client Initialization/Termination

   Usually clients running on the same instance of HDPMI will share address
   space, IDT and LDT. On client initialization HDPMI will do:

   - save the current IDT
   - save the current LDT
   - save other client resources, among which are
     + real-mode callbacks
     + ring 3 interrupt vectors
     + ring 3 exception vectors

   These resources are saved, but not initialized, that is, a new client
   will inherit the state of the previous client.

   On client termination, HDPMI will do:

   - free memory handles the client has allocated
   - restore the IDT to the previous state
   - restore the LDT to the previous state
   - restore other resources to the previous state

   So there is no need for a client to free memory or LDT selectors before
   terminating. Conventional DOS memory blocks and file handles will be 
   released by DOS, but any real-mode interrupt vectors which were modified
   must be restored by the client.

   If HDPMI has been told to give each client its own address context, things
   are different of course. Address space, IDT and LDT are no longer shared,
   and the client will get "clean" copies of IDT and LDT. On termination, the
   client's resources are just thrown away.


 6.6 DPMI API

   HDPMI fully supports DPMI version 0.9.

   Additionally, the following DPMI v1.0 features are supported:

   Int AX    comment
   -----------------------------------------------------------------
   2F  168A  get vendor-specific API entry point
   31  000E  get multiple descriptors
   31  000F  set multiple descriptors
   31  0210  get protected-mode extended exception handler
   31  0212  set protected-mode extended exception handler
   31  0401  get DPMI capabilities, Vendor is "HDPMI". This is the
             recommended way to detect that HDPMI is present.
  *31  0504  allocate linear memory block
  *31  0505  resize linear memory block
  *31  0506  get page attributes
  *31  0507  modify page attributes
  *31  0508  map device in memory block
  *31  0509  map conventional memory in memory block
  *31  050A  get memory block size and base
  *31  050B  get memory information
   31  0801  unmap physical region
   31  0E00  get coprocessor status
   31  0E01  set coprocessor emulation

  * support for these functions can be disabled by commandline parameter
    or setting environment variable HDPMI.

   So most DPMI V1.0 features are implemented, what's missing are:

   - 0211h + 0213h, get/set handler for real-mode exceptions
   - 0C00h + 0C01h, DPMI TSRs
   - 0D00h - 0D03h, shared memory

   Additionally, some privileged opcodes are emulated:

   - HLT (F4) 
   - MOV reg,CRx (0F 20 xx) - using ESP for <reg> will not work!
   - MOV CRx,reg (0F 22 xx) - using ESP for <reg> will not work!


 6.7 VDS API

   The following VDS functions (Int 4Bh, AH=81h) are supported in
   protected-mode:

   AL  Function               Comment
   -----------------------------------------------------------------------
   03  lock region            routed to v86-mode with translation of ES:E/DI
   04  unlock region          routed to v86-mode with translation of ES:E/DI
   05  scatter/gather lock    handled by HDPMI. ES:E/DI must point to a EDDS.
   06  scatter/gather unlock  handled by HDPMI. Indeed it is mostly a No-Op,
                              just the parameters are checked for validity.
   07  request DMA buffer     routed to v86-mode with translation of ES:E/DI
   08  release DMA buffer     routed to v86-mode with translation of ES:E/DI
   09  copy into DMA buffer   routed to v86-mode with translation of ES:E/DI
   0A  copy out of DMA buffer routed to v86-mode with translation of ES:E/DI

   VDS functions 02 and 0Bh-0Ch are routed to real/v86-mode without 
   translation.
   Implementation of function 05 will allow linear-to-physical address
   translation for any valid linear address. If an address space contains
   uncommitted pages, bit 6 of DX must be set to return PTEs, else the call
   will fail. 
   Functions which are routed to v86-mode with ES:E/DI translation will not
   be able to handle linear addresses managed by HDPMI, that is, they might
   work for address space 0-110000h only.
   
   Please be aware that if DOS is running in real-mode (no EMM is loaded),
   then calling functions other than 05-06 most likely will fail. Therefore
   bit 5 at 40h:007Bh should be checked if VDS is available.


 6.8 DOS API Translation

   HDPMI supports DOS-API translation, both in 16-bit mode and in
   32-bit mode. For translation purposes, HDPMI allocates a static
   translation buffer of 8 KB. For the important read/write functions
   HDPMI will try to allocate a temporary 64k buffer, if the size of
   the i/o-operation exceeds the size of the static translation buffer.

   Supported DOS extended INT 21h functions in detail:

    AH  Comment  
    -----------------------------------------------------------
    00  close current PSP without terminating client
    09  Write String DS:E/DX to Standard Output
    0A  Buffered Input into DS:E/DX
    0C  AL=0A, Flush Buffer and read Standard Input into DS:E/DX
    11  Find First File using FCB in DS:E/DX
    12  Find Next File using FCB in DS:E/DX
    13  Delete File using FCB in DS:E/DX
    1A  Set Disk Transfer Area to DS:E/DX
    1B  Get Allocation Information for Default Drive in DS:E/BX
    1C  Get Allocation Information for Specific Drive in DS:E/BX
    1F  Get Drive Parameter Block for Default Drive in DS:E/BX
    25  Set Interrupt Vector in DS:E/DX
    29  Parse Filename in DS:E/SI into FCB in ES:E/DI
    2F  Get Disk Transfer Area in ES:E/BX
    32  Get Drive Parameter Block for Specific Drive in DS:E/BX
    34  Get Address of InDOS Flag in ES:E/BX
    35  Get Interrupt Vector in ES:E/BX
    38  DX!=FFFF, Get Country-Specific Information in DS:E/DX
    39  Create Subdirectory DS:E/DX
    3A  Remove Subdirectory DS:E/DX
    3B  Set Directory DS:E/DX
    3C  Create File DS:E/DX 
    3D  Open File DS:E/DX
    3F  Read E/CX bytes from File to DS:E/DX
    40  Write E/CX bytes from DS:E/DX to File 
    41  Delete File DS:E/DX
    43  Get/Set File DS:E/DX Attributes
    44  AL=02 Read from Char Device Control Channel into buffer DS:E/DX
    44  AL=03 Write to Char Device Control Channel from buffer DS:E/DX
    44  AL=04 Read from Block Device Control Channel into buffer DS:E/DX
    44  AL=05 Write to Block Device Control Channel from buffer DS:E/DX
    44  AL=0D Generic Block Device Request, parameter block in DS:E/DX
    47  Get Directory Path into DS:E/SI
    48  Allocate Memory Block E/BX paragraphs
    49  Free Memory Block in ES
    4A  Resize Memory Block ES, new size in E/BX
    4B  AL=00 - Load and Execute Program DS:E/DX, exec parm ES:E/BX
    4C  terminate client
    4E  Search for First Filename Match, DS:E/DX=file spec
    50  Set current PSP to BX (selector)
    51  Get current PSP in BX (selector)
    52  Get List of Lists in ES:E/BX
    53  Translate BPB in DS:E/SI to DPB in ES:E/BP
    55  Create Child PSP from DX (selector)
    56  Rename File DS:E/DX to ES:E/DI
    5A  Create temporary File DS:E/DX 
    5B  Create new File DS:E/DX 
    5D  AL=06 Get Address of DOS Swappable Data Area in DS:E/SI
    5D  AL=0A Set extended error information from DS:E/DX
    5E  AL=00 Get Machine Name into DS:E/DX
    60  Canonicalize Filename or Path in DS:E/SI to ES:E/DI
    62  Get current PSP in BX (selector)
    63  AL=00 Get DBCS table in DS:E/SI
    65  AL=00 Set extended Country Information from ES:E/DI
    65  AL=01-07 Get extended Country Information into ES:E/DI
    65  AL=21|22|A1|A2 capitalize string in DS:E/DX
    69  Get/Set disk serial number in DS:E/DX 
    6C  Extended Open/Create, file name in DS:E/SI 
   *71  AL=39|3A|3B LFN subdirectory functions DS:E/DX
   *71  AL=41 LFN delete file DS:E/DX
   *71  AL=43 LFN get/set file attributes DS:E/DX
   *71  AL=47 LFN get current directory DS:E/SI
   *71  AL=4E LFN get first file DS:E/DX into ES:E/DI
   *71  AL=4F LFN get next file into ES:E/DI
   *71  AL=56 LFN rename file DS:E/DX to ES:E/DI
   *71  AL=60 LFN get canonical/short/long path DS:E/SI to ES:E/DI
   *71  AL=6C LFN open file DS:E/SI
   *71  AL=A0 LFN get volume info DS:E/DX, return file sys into ES:E/DI
   *71  AL=A6 LFN get file info by handle into DS:E/DX
   *71  AL=A7 LFN filetime DS:E/SI to dostime - dostime to filetime ES:E/DI
   *71  AL=A8 LFN generate short filename from DS:E/SI to ES:E/DI 
   *71  AL=AA LFN create SUBST DS:E/DX, query SUBST DS:E/DX
    73  AL=02 Get extended DPB into ES:E/DI
    73  AL=03 Get extended free space into ES:E/DI
    73  AL=04 Set DPB for formatting in ES:E/DI
    73  AL=05 Extended absolute disk read/write with params in DS:E/BX

   * LFN (AH=71h) API translation only works if LFN is installed in 
     real-mode DOS. Usually this requires a driver to be installed (DOSLFN).


 6.9 Other API Translation Support

   Int Function Comment
   ---------------------------------------------------------------------
   10  ax=1002h set all palette registers ES:E/DX
   10  ax=1009h get all palette registers ES:E/DX
   10  ax=1012h set DAC registers ES:E/DX
   10  ax=1017h get DAC registers ES:E/DX
   13  ah=02h   disk read into buffer ES:E/BX
   13  ah=03h   disk write from buffer ES:E/BX
   13  ah=08h   for FD return drive parameter table in ES:E/DI
   15  ah=C0h   read configuration into ES:E/BX
   15  ax=C207h set pointing device event proc ES:E/BX
   25           absolute disk read buffer in DS:E/BX
   26           absolute disk write buffer in DS:E/BX
   2F  ax=168Ah supports vendor "MS-DOS" and "VIRTUAL SUPPORT" 
                callback for "MS-DOS" supports function 100h (LDT sel)
   33  ax=0009h define graphics cursor ES:E/DX
   33  ax=000Ch define interrupt subroutine ES:E/DX
   33  ax=0012h define large graphics cursor ES:E/DX
   33  ax=0014h exchange interrupt subroutine ES:E/DX
   33  ax=0016h save driver state ES:E/DX
   33  ax=0017h restore driver state ES:E/DX
   33  ax=0018h set alternate mouse user handler ES:E/DX


 6.10 Debug Support

   a) Support in Protected Mode

   HDPMI supports Int 41h processing in protected mode. HDPMI provides
   that ring 0 Int 41h calls are not reflected in ring 3. It's also
   ensured that no Int 41h call will be reflected to real mode.

   HDPMI itself issues three Int 41h calls, all in ring 0 (and therefore
   only of use for kernel debuggers):

     - on initialization of the server
     - a breakpoint if a new DPMI clients starts
     - on termination of the server

   Environment switch HDPMI=8192 will cause HDPMI to set the client's
   trace flag on its initial switch to protected-mode. This should work
   with any DPMI-aware debugger.
   
   Furthermore, there are enough free entries left in the GDT to allow
   HDPMI itself being debugged by Qualitas' debugger 386SWAT. Requires
   GDT in extended memory, so switch HDPMI=512 must not be set for this
   to work.

   b) Support in Real Mode

   Kernel debuggers such as WDEB386.EXE start in real mode and before any
   DPMI server is active. That's why they need some support from the
   DPMI server to get a chance to do their protected mode initialization,
   (to modify IDT vectors they want to hook or set GDT descriptors).
   For this reason HDPMI supports WDEB386's real-mode Int 68h API.

   c) Other Debug Support

   - the value of the trace flag is preserved if a mode switch occurs.
     The switch from real mode to protected mode has been made "debug
     aware", so that there is no risk a debugger traces into nontracable
     code, thereby crashing the system.

   - if HDPMI detects a kernel debugger, its output is send to the debugger.
     If an exception occurs, the debugger will be notified as well,
     giving it a chance to stop execution.


 6.11 Nested Execution of several DPMI Clients

   As already mentioned, usually if two or more clients share one instance
   of HDPMI, they also have to share address space, IDT and LDT. For most
   clients this is no problem at all. But on certain conditions it may be
   necessary to not share these resources. Therefore HDPMI optionally allows
   to run each client in its own address context. Thus the clients will only 
   share DOS specific resources (address space 0-10FFFFh, files, IVT vectors)
   and (physical) extended memory. 


 6.12 Other Features of HDPMI

  þ  clients run with CPL 3, and IOPL is 3. This means, instructions like
     STI, CLI, IN or OUT are executed in real time.
  þ  during ring 0 processing NMIs are ignored.
  þ  HDPMI's ring 0 ESP will always have its hiword cleared. This is because
     of a design weakness in Intel CPUs, which don't touch the Hiword of ESP
     on a switch to a lower privilege level if the D bit of the destination
     ring SS descriptor is not set (16-bit stack). Some 32-bit DPMI clients 
     which (temporarily) use a 16-bit stack aren't aware of this potential
     problem, among these are apps written with the DOS4G extender.
  þ  A client can allocate up to 16 real-mode callbacks. 


 7. Restrictions of current Version

  þ If no XMS host is found, HDPMI must switch the A20 gate on its own. Only
    standard AT (keyboard controller) and PS/2 (bit 1 of port 92h) methods
    are supported. The gate is enabled once on server initialization.
  þ Int 25h/26h (and Int 21h, ax=7305h for FAT32) translation services:
    the amount of bytes to read/write per call is limited to the size of
    the static translation buffer, which is 8 kB.
  þ Exceptions >= 12h aren't supported/detected.


 8. Known Problems / Hints

  þ Some versions of DOS4G/W require environment variable HDPMI=1 to be
    set. Generally, setting this option should be the first thing to do
    if a client doesn't run with HDPMI.

  þ Some DOS extenders will prefer to use a VCPI host over DPMI and thus
    ignore an installed copy of HDPMI. Usually there is a way to make them
    change their mind:

    - CauseWay: set environment variable "CAUSEWAY=DPMI"
    - PMODE/W: use tool PMWSETUP to set switch "prefer DPMI over VCPI"
    - DOS/32A: set environment variable "DOS32A=/DPMITST:1" or run SS.EXE

  þ Some programs don't expect system tables (GDT, IDT, LDT) being located
    at very high linear addresses, as it is the case with HDPMI by default.
    To make HDPMI compatible with such programs, environment variable
    HDPMI=512 has to be set before HDPMI is loaded. The SoundBlaster 16
    emulation for SB-PCI or SB-Live sound cards (SBINIT.COM/SBEINIT.COM)
    may belong to these kind of programs. 

  þ Some clients may require to disable HDPMI's support for DPMI V1.0
    memory functions (examples: 1. apps built with DJGPP v2 because of
    the NULL pointer protection problem. 2. the game "Inner Worlds"). 
    This can be achieved by starting HDPMI with parameter -m or by setting 
    environment switch HDPMI=1024.

  þ Some combinations of DOS, HDPMI32 and Borland's 32RTM.EXE will only
    work with environment switch HDPMI=2048. This is due to a bug in
    32RTM.EXE.

  þ Some clients are incompatible with HDPMI if it hasn't been installed
    with option -r. Usually this is because they try to restore real-mode
    interrupt vector 2Fh too late (after HDPMI has done its cleanup).
    PMODE/W and DOS/32A applications may belong to these type of programs.

  þ If HDPMI is loaded and a client refuses to run and tells that it doesn't
    like to run in a Win9x DOS box, try to set HDPMI=16384 before HDPMI is
    loaded.

  þ To run a 16-bit client while HDPMI32 is installed requires to install
    HDPMI16 before HDPMI32. The best thing to do if both types of clients
    are to be executed is to run first HDPMI16, then HDPMI32, both with
    option -r.

  þ if HDPMI is loaded residently and the Watcom debugger WD is launched
    to debug a protected mode application it may display a message that
    it cannot do that on a DPMI 0.9 host. Then set environment variable
    HDPMI=36. This will report a DPMI 1.0 host to WD and separate the
    debugger's and debuggee's address space.

  þ Some clients refuse to run if the amount of free memory is too *large*
    (for example the game 'System Shock'). The HX runtime contains a 
    DPMI test program called DPMI.EXE, which can be used to reduce the
    amount of memory the host reports. It should work with any host. Start
    DPMI.EXE with option -? to see how this can be done.

  þ Some clients regard the amount of free physical pages as safe to
    allocate. This may work ok for hosts which use a swapfile, but HDPMI
    doesn't and therefore the request is likely to fail. Option -n might 
    make such clients work (example: "Blood" game).

  þ If the machine reboots on certain actions it's not unlikely that this
    is due to a real-mode stack overflow. What sometimes may help then is:
    - set STACKS=9,512 in CONFIG.SYS (may introduce new problems though)
    - try to load another mouse/network/sound driver


 9. Compatibility List

   the following applications/DOS extenders are verified to run with HDPMI:

   - DOS4/GW Rational/Tenberry DOS extender
   - PMODE/W DOS extender
   - CauseWay DOS extender
   - DOS/32 Advanced DOS extender
   - Borland Powerpack (16 + 32-bit)
   - WDOSX extender
   - RSX DOS extender
   - RAW32 DOS extender
   - X-32 DOS extender (Digital Mars)
   - Pharlab TNT DOS extender (i.e. MS VC 1.52)
   - DJGPP applications.
   - MS Windows 3.1 (standard mode)
   - MS Windows for Workgroups 3.11 (standard mode)
   - MS DOSX16/DOSX32 applications (Codeview for DOS, MS C++ 7.0)
   - MicroFocus COBOL applications (16 + 32-bit)
   - kernel debugger WDEB386.EXE/WDEB98.EXE/DEBUGGER.EXE
   - 386SWAT, Qualitas' ring 0 debugger 

   HDPMI itself has been tested to run under the following emulators:

   - Bochs
   - Qemu
   - VMWare
   - VirtualBox
   - DosBox (version must be >= 0.70)

   Wth Virtual PC 2007 the standard HDPMI binary will not work. However,
   there is a modified HDPMI32.EXE available which might work and can be
   found at http://www.japheth.de/hx.html.

   HDPMI has also been tested to run with the following VCPI hosts:

   - MS-DOS Emm386 (V7.x, V6.x, V5.0)
   - Jemm
   - FreeDOS Emm386 (V2.x)
   - Quarterdeck Qemm386 (V6, V8, V9)
   - Qualitas 386Max (V6.02, V7.02)


 10. History

  20.01.2009, version 3.16

  þ Assembler switched to JWasm.
  
  01.03.2008, version 3.15
  
  þ bugfix: int 31h, ax=507h didn't return number of processed pages
    in ECX if function failed.
  þ bugfix: an exception 11h might have occured inside hdpmi's cpu test
    if CR0 AM bit was set on init.
  þ bugfix: translation of int 21h, ax=7305h didn't set realmode-DS
    to TLB, making the call fail under certain conditions.
  þ int 31h, ax=507h now returns error code 8013h if functions fails 
    because of lacking free physical memory.
  þ XMS memory allocation strategy slightly changed to avoid running out
    of XMS handles if client allocates just small portions and number
    of XMS handles is limited to 32.
  þ kernel debugger support split into WDEB386 and 386SWAT. Int 22h (Win386)
    protected-mode debug "API" disabled.
  þ Exception 11h (alignment fault) is now supported.
  þ HiWords of general purpose registers preserved on initialization.
  þ CR0 MP and EM bits are now cleared for the first client only. This
    allows to implement an FP emulator DPMI TSR.
  
  11.01.2008, version 3.14

  þ IOPL0 version only: added support for string IO.
  þ group names changed to allow linking HDPMI object modules into other
    binaries.
  þ "stub" version of HDPMI (HDPMI32.BIN) added.
  þ bugfix: translation of int 15h, ax=C207h (set PS/2 mouse event proc),
    has caused a GPF if called with ES=0.
  þ bugfix: if client used Int 33h translations, set a mouse event proc
    and HDPMI wasn't installed residently, a memory corruption may have
    occured on host exit.
  þ bugfix: int 31h, ax=506h didn't work correctly for mapped pages (int
    31h, ax=508h/509h). It returned them as "committed".
  þ bugfix: a missing "assume" caused a destructive write to memory in
    HDPMI's conventional memory portion (XMS mode).

  15.07.2007, version 3.13

  þ bugfix: the EMS handle allocated in v3.12 might have been released 
    multiple times if HDPMI was installed with option -a or HDPMI=32 was
    set. This could have affected other applications using EMS.
  þ bugfix: the EMS handle allocated in v3.12 wasn't released if host
    ran out of memory on init.
  þ bugfix [HDPMI16 only]: translation for int 21h, ax=7160h used ES:EDI
    as target for translated name. Corrected to use ES:DI only.
  þ bugfix: commandline option -m didn't work in v3.07-v3.12.
  þ real-mode callbacks are disabled and mouse is reset before requesting
    key for client/server termination in the default exception handler.
  þ options -n, -k implemented.
  þ option -g implemented in source (currently deactivated) to prohibit
    usage of INVLPG opcode.
  þ an additional 4k page is allocated on startup, which avoids a possible
    GPF if free extended memory on init is small (<= 3 MB).

  15.03.2007, version 3.12

  þ bugfix (HDPMI16 mainly): if int 31h, ax=0100h succeeded to alloc DOS 
    memory, but no more LDT descriptors were available, the call returned with
    Carry set, but the DOS memory block wasn't released.
  þ bugfix (HDPMI16 only): if int 31h, ax=102h failed because of insufficient
    descriptors, it didn't reset the memory block's size to its previous
    value.
  þ bugfix (HDPMI16 only): int 21h, ah=48h, BX=-1 did return a valid memory
    block. Now it fails in any case, returning free memory (max. FFFEh) in
    register BX (similar to Win9x' DPMI host).
  þ bugfix: if the XMS hook chain did contain a hooker which doesn't
    start with 0EAh/0EBh, HDPMI has caused a crash.
  þ bugfix: error condition DOS < v4 caused a garbage display.
  þ allocated size of dynamic TLB was still 0FFF0h, though 0FE00h bytes were
    used only.
  þ on FATAL exceptions now value of CS:EIP is additionally displayed.
  þ before calling XMS "query free memory" register BL is set to zero.
    Makes HDPMI work better with some (old) XMS hosts.
  þ minimal DOS version required to run HDPMI is now v3.3.
  þ if a EMM/VCPI host is detected, an (empty) EMS handle is allocated on
    startup to ensure the EMM host keeps ON and installed.
  þ the host now uses the DOS SDA (swappable data area) if it needs to know
    the current PSP segment for internal reasons.

  14.12.2006, version 3.11

  þ bugfix: if a client allocated very large uncommitted memory blocks,
    HDPMI may have grabbed (almost) all XMS memory.
  þ bugfix: on init option -i may have caused a stack exception if HDPMI was 
    running in VCPI mode.
  þ bugfix: int 21h, ah=4Ah first increased memory block and then tried
    to alloc additional descriptors (16-bit only). If there were not enough
    descriptors, the function failed, but the memory block kept its new
    size, thus wasting memory.
  þ size of dynamic TLB reduced from 0FFF0h to 0FE00h, which increases
    speed of large file read/write operations in FreeDOS/DR-DOS.

  15.10.2006, version 3.10

  þ bugfix: the routine which checked whether an XMS memory handle could be 
    released (relevant only if HDPMI is installed with -r) may have caused
    a GPF.
  þ bugfix: translation for int 21h, ax=6300h checked carry flag if dos call
    was successful, but this call returns AL=00 in case of success instead.
  þ bugfix: if Ctrl-Alt-Del is detected, there is no longer an int 21h,
    ax=4CFFh issued in protected-mode if current PSP is not the one of the
    active client.
  þ bugfix: int 4Bh, ax=8102h (get VDS version) was not routed to real-mode,
    but since it uses no pointers it should be routed.
  þ the VDS functions which expect a pointer to a DDS in ES:E/DI (03-04, 
    07-0A) are now  translated and routed to v86-mode.
  þ VDS functions 05h and 06h are handled by HDPMI.
  þ int 21, ah=4Ah translation: if memory block to resize is in conventional
    memory, now the error code received from real-mode dos is returned.
    Previously it always returned ax=8 and available paragraphs in E/BX.
  þ when installed permanently with -r HDPMI now grabs less XMS memory.
  þ Int 31h, ax=0000: if the request has no chance to be successful (too
    many descriptors requested), size of LDT now remains unchanged.
  þ new value for environment variable HDPMI:
    32768 - prevent HDPMI from touching CR0 NE bit.

  14.09.2006, version 3.09
  
  þ bugfix: if DOS int 21h, ax=440Dh did not require translation, it may
    have returned with Carry set, but in fact did not call DOS at all.
  þ bugfix: translation for int 26h, cx=ffffh (FAT16 absolute disk write)
    may have caused data corruption on the drive, translation for int 21h,
    ax=7305h, si[0]=1 (FAT32 absolute disk write) failed in any case.
  þ when running under a VCPI host, bit 1 in host flags (int 31h, ax=0400h)
    returned in BX will now be cleared.

  15.08.2006, version 3.08

  þ mode switches now slightly faster when running as VCPI client.
  þ bugfix: exceptions during initialization while no client is running yet
    (inside a VCPI memory function for example) weren't handled properly,
    which made the system unstable and required a reboot.
  þ bugfix: option -a used on a system with VCPI but no XMS may have caused
    troubles on nested execution of clients.
  þ bugfix: the default exception handler displayed garbage as client's
    CS:EIP and SS:ESP on ring 0 exceptions if there was no client running
    (host idle or initializing).
  þ HDPMI v3.07 was not compatible with VMware, because VMWare seems to not
    properly emulate the 80386 paging TLB. Workaround implemented.
  þ cmdline options -v and -y added.
  þ in raw mode port 92h ("fast" A20 gate) is no longer touched if BIOS
    is telling that this method is not available.

  21.07.2006, version 3.07a

  þ bugfix: environment variable HDPMI=512 didn't work in v3.07.

  15.07.2006, version 3.07

  þ bugfix: if the host run more than one client, it may have modified
    the real-mode stack of previous client during client termination.
  þ optionally run each client in its own address context
  þ meaning of value 32 for environment variable HDPMI changed. The previous
    meaning is now achieved by setting HDPMI=16384 (which is rarely used).
  þ new cmdline options -i, -s and -v.
  þ the HDPMI binary now is linked so that the DOS loader will load the
    real-mode part only. The protected-mode part is loaded delayed, which
    allows to load HDPMI in much smaller UMBs.
  þ HDPMI will now use the TLB of any instance of the host found in
    memory, enabled or disabled.
  þ additional security check if a parent psp has to be translated back
    to a segment.

  14.06.2006, version 3.06

  þ new value for environment variable HDPMI:
    8192 - break into client after initial switch to protected mode.

  15.05.2006, version 3.05

  þ bugfix: int 31h, ax=0101h may have caused an exception if selector of  
    memory block to free was contained in DS.
  þ bugfix: in previous versions the real-mode DTA was set permanently to the
    hosts's PSP+80h. This apparently was a problem for some clients not using
    the host's DOS translation services (F-PROT.EXE).
  þ bugfix: if int 31h, ax=101h|102h did not fail it still returned with a
    modified AX register
  þ bugfix: int 21h, AH=4Ah returned with modified AX register.
  þ bugfix: int 31h, AX=050Bh returned 0 in "maximum locked bytes" field. Now
    the "free" bytes are returned.
  þ bugfix: int 31h, ax=0507h didn't work with ECX=0 in versions 3.02-3.04
    (32RTM.EXE does such a call and expects it to succeed)
  þ bugfix: cmdline option -u didn't work if environment variable HDPMI=1
    was set and HDPMI run as VCPI client.
  þ bugfix: raw mode switch to protected mode may have enabled interrupts
    one instruction too early, which caused a GPF if a IRQ occured.
  þ CR4 now displayed by default exception handler
  þ default exception handler no longer makes assumptions about value of SS
    if an exception occured in ring 0.
  þ some free entries in GDT added which is required by 386SWAT to debug
    VCPI clients.

  02.05.2006, version 3.04

  þ bugfix: in Int15/raw mode only part of physical memory was used
  þ bugfix: HDPMI installed with option -r and DOS memory included in
    page pool (HDPMI=2) didn't work reliably.
  þ bugfix: translation for Int 33h, ax=0016h (save driver state) didn't
    work.
  þ bugfix: freeing a real-mode callback which was already free didn't
    set the carry flag.
  þ bugfix: total physical memory reported by Int 31h, ax=0500h was too low
    after more than 1 XMS memory block was allocated.
  þ bugfix: free pages reported  by Int 31h, ax=0500h now are the true
    free physical pages. Previously it was just the same value as in field
    "max unlocked page allocation". 
  þ XMS memory handles (except the first one) now released if a resident
    installed HDPMI enters idle state (no client running).
  þ CR0 no longer saved/restored when a client starts/exits, just the
    FPU bits are maintained on the client level (to support Int 31h, 
    ax=0E0xh). CR0 MP bit is no longer reset on initialization. 
    Meaning of cmdLine option -t changed to "don't touch NE bit", 
    previously it was "do reset NE bit".
  þ in Int 31h, ax=0500h VCPI host was called if no free XMS pages exist
    anymore. This is a problem with at least one popular VCPI host and
    should therefore be avoided.
  þ now flags are saved/restored in Int 15h/2Fh real-mode hook procs
  þ new value for environment variable HDPMI:
    4096: make pages for GDT, IDT, LDT readonly

  21.04.2006, version 3.03

  þ bugfix: in V3.02 API translation Int 21h ah=29h didn't work for 16-bit
    clients.
  þ bugfix: in V3.02 routing interrupts 78h - FFh to real-mode didn't work
  þ bugfix: client initialization errors (out of memory or selectors) 
    may have left the system unstable.
  þ bugfix: low memory conditions on host initialization may have left the
    system unstable.
  þ in previous versions HDPMI needed some pages to be temporarily mapped
    in page table 0 on startup, which may cause a problem in VCPI mode
    if there are no free PTEs left. Now this temporary mapping is no longer 
    needed.
  þ command line option -b added to further reduce DOS memory usage.
  þ missing LFN translations (ax=71A7h, 71A8h and 71AAh) added.
  þ DPMI v1.0 functions to get/set multiple descriptors (int 31h, 
    ax=000Eh/000Fh) implemented
  þ DPMI v1.0 functions to get/set exception handlers for protected-mode
    (int 31h, ax=0210h/0212h) implemented
  þ DPMI v1.0 "exception restartability" supported.

  12.04.2006, version 3.02

  þ bugfix: internal function to alloc XMS memory was unable to detect
    a XMS host failure in V3.01.
  þ bugfix: change in V1.87 caused the critical error interrupt (INT 24h)
    to not work reliably.
  þ bugfix: resize linear memory block (Int 31h, ax=0505h) did always
    commit the added pages (ignored bit 0 of edx).
  þ GDT now moved to extended memory (unless switch HDPMI=512 is set).
  þ rest of missing DPMI v1.0 memory functions implemented:
    ax=505h: segment descriptor update now supported
    ax=508h: map device in memory block
    ax=509h: map conventional memory in memory block
    ax=50Ah: get memory block size and base
    ax=50Bh: get memory information
  þ API translation Int 33h, ax=0016h and ax=0017h wasn't documented.
  þ new value for environment variable HDPMI:
    2048: clear hiword of ESI/EDI on client's initial switch to protected
          mode.

  07.04.2006, version 3.01

  þ bugfix: int 21h, ah=4F (find next file) in v3.0 may have caused
    data corruption.
  þ some more data moved into extended memory to free conventional DOS
    memory.
  þ new value for environment variable HDPMI:
    1024: disable support for DPMI v1.0 memory functions

  04.04.2006, version 3.0

  þ HDPMI32 and HDPMI16 will share a TLB, which reduces conventional
    memory consumption by 8 kB if both hosts are loaded residently.
  þ host code running in protected mode moved to extended memory.
    This reduces HDPMI's conventional DOS memory usage from about
    32 kB to 14-15 kB (including a 8 kB TLB).
  þ host protected-mode code now runs in a 32-bit code segment.
  þ use VCPI memory allocation if no XMS host found.
  þ new values for environment variable HDPMI:
    128: disable LFN API translation
    256: enable HMA mapping in protected mode if HDPMI runs as VCPI client
    512: allocate IDT and LDT in client address space (SBPCI problem)

  21.03.2006, version 2.07

  þ bugfix: internal function to call a real-mode interrupt cleared
    the carry flag before calling the INT. This caused troubles with
    LFN functions on MS-DOS < 7 and DR-DOS.
  þ bugfix: trying to terminate a client if Ctrl-Alt-Del was pressed
    didn't work for HDPMI16.

  20.03.2006, version 2.06

  þ Exception 05 is no longer routed to real-mode. It is still routed
    to protected mode Int 05, though. To real-mode is will only be routed
    if it is a programmed INT 05, else the client will be terminated.
  þ bugfix: default exception handler didn't display a register dump.
  þ small code size reduction.

  18.03.2006, version 2.05

  þ bugfix: strings displayed with int 21h, ah=9 weren't checked if their
    size exceeds size of TLB.
  þ debug exceptions now detected by examining DR6, not by content
    of cs:eip or trace flag.
  þ added a test in raw mode if size of extended memory between 1 MB and 16 MB
    as returned by Int 15h, ax=e801, does not exceed 15360. Else this function
    is regarded as 'not implemented' (required for DosBox in raw mode).
  þ test if vector is 0000:0000 before calling Int 68h in real-mode.
    This makes HDPMI compatible with DosBox (tested with DosBox V0.63).
  þ bugfix: int 31h, ax=090xh didn't work in HDPMI16.
  þ int 31h entry in IDT now directly jumps into the host's int 31h
    handler, which improves this int's speed (especially useful for virtual
    interrupt functions, which are now 4 times faster than before). 

  06.02.2006, version 2.04

  þ HDPMI16 and HDPMI32 now both may be installed resident concurrently.
  þ ES, FS and GS selectors caches now updated after int 31h, ax=000Ch
    has modified a descriptor.

  22.01.2006, version 2.03

  þ check if VCPI host has remapped PICs. Exit with error 6 if this
    is true.
  þ supply some extra bytes of stack space to make HDPMI run
    with QEMM V8+V9 VCPI hosts.

  29.12.2005, version 2.02 

  þ bugfix: freeing memory (int 31h, ax=502h) or setting page
    attributes (int 31h, ax=506h) did not invalidate the TLB
    entries. This may have caused problems on some conditions.

  18.11.2005, version 2.01

  þ small size reduction

  30.10.2005, version 2.00

  þ default exception handler now sends an EOI to slave PIC if
    any interrupt is in service.

  15.10.2005, version 1.99

  þ default exception handler now sends an EOI to master PIC if
    any interrupt is in service.

  27.09.2005, version 1.98

  þ functions int 31h, ax=506h and ax=507h now accept ecx=0
    (number of pages) to make 32rtm.exe not complain about
    insufficient extended memory.
  þ bugfix: versions 1.89-1.97 of HDPMI32.EXE may have caused
    a stack exception on 80386 + 80486 cpus when client has
    just switched to protected mode. HDPMI32 used a 16-bit
    IRET to return to the client, but this may have trashed
    hiword of ESP.

  16.09.2005, version 1.97

  þ if HDPMI is resident real-mode vectors are now restored after last client
    has terminated. Previously it was done when HDPMI was uninstalled.
  þ new switch HDPMI=64 implemented.
  þ bugfix: Unsupp\HDPMI16.EXE had a bug in int 2Fh, ax=1684h
    making it unable to run windows 3.1.
  þ bugfix: if int 31h, ax=504h, ebx=0 failed it returned with modified EBX.
  þ bugfix: using DOS memory for the page pool (HDPMI=2) didn't
    take into account a bug in many DOS versions where a failed
    call to resize a memory block made this block as large as possible.
  þ bugfix: allocating linear memory with int 31h, ax=504h, ebx!=0
    may have failed, but Carry flag wasn't set. This occured if a
    memory block was allocated previously with a higher linear address.

  06.09.2005, version 1.96

  þ exc 09 checks disabled if cpu is 80486+.

  18.08.2005, version 1.95

  þ flag for RMS usage implemented. This allows in raw jump to
    protected mode to not touch current RMS if it is not in use.
    (the win9x dpmi host has problems with this constellation).

  13.08.2005, version 1.94

  þ bugfix: a mode switch may have changed values of the FPU emulation bits
    in CR0. Now all bits of CR0 except PE and PG are copied between modes.
  þ translation for int 21h, ah=69h added. Previously calling this function
    failed with an error message displayed.

  30.07.2005, version 1.93

  þ mov CRx,reg now emulated. This feature (mov CR0, reg) is required by
    some clients (MS C v7.0 [16-bit]).
  þ XMS handles are now released after HDPMI has finally switched to
    real-mode. The previous behavior seemed to cause problems with
    Bochs/Qemu running HDPMI.
  þ documentation of HDPMI error codes 8 and 9 was wrong
  þ new switch HDPMI=32 implemented
  þ bugfix: environment switch HDPMI=16 didn't work
  þ owner psp of dyn TLB memory block set to psp of current client. This
    may avoid memory leaks if Ctrl-C is pressed while reading the console
    with int 21h, ah=3Fh.
  þ previous versions of the 16-bit host HDPMI16 used 286-interrupt gates
    to switch from ring-3 to ring-0 protected mode, thus loosing HIWORD of
    the client's ESP. Now such transfers are done thru 386-interrupt gates
    and the client's ESP remains untouched. This finally makes IR41.DLL 
    (16-bit Intel Indeo video codec for Windows 3.1) work with HDPMI16.

  20.07.2005, version 1.92

  þ bugfix: HDPMI may have frozen the machine on initialization
    errors (low memory)
  þ bugfix: in raw mode switch 'real-mode to protected mode' now the
    real-mode ss:sp is stored as current real-mode stack, because
    the previous stack cannot be used anymore, it is "busy".
  þ bugfix: int 31h, ax=0401h didn't return the correct host
    minor version number.
  þ bugfix: translation of int 25h/26 (absolute disk read/write)
    may have overwritten 2 bytes in the host's code segment.
  þ bugfix: dpmi functions int 31h, ax=0301h/0302h didn't work
    in version 1.91 if stack parameters had to be copied.
  þ new environment flag HDPMI=16, which prevents HDPMI from
    using a 64 kB dynamic TLB.

  15.07.2005, version 1.91

  þ bugfix: when shutting down HDPMI marked PTEs as notpresent
    which were owned by VCPI host. This caused 386MAX and FreeDOS
    EMM386 to crash.
  þ bugfix: uninstalling a resident instance of HDPMI (option -u)
    may have overwritten dos memory due to the usage of a real-mode
    stack which was no longer valid.

  10.07.2005, version 1.90

  þ bugfix: now *all* files are closed before going resident.
    Previously files 0-2 were left open, which may have been a
    problem if they have been redirected.
  þ int 21h API translator didn't set Carry flag before calling
    real-mode dos int 21h (HDPMI32 with LFN support only). This
    caused problems with DR-DOS.

  04.07.2005, version 1.89

  þ code modified to use a static task state buffer, which
    simplified the raw mode switching code.
  þ bugfix: raw mode switch to real-mode didn't clear FS and GS
  þ display of open real-mode callbacks in default exception
    handler rearranged.
  þ bugfix: int 31h, ax=0300h, 0301h, 0302h didn't save/restore
    client's real-mode segments. So the values in the RMCS became
    the client's new real-mode segments.
  þ standard real-mode callbacks (used for IRQs, int 1Ch, 23h, 24h)
    did save real-mode segment registers on the real-mode stack, but
    didn't update the client state. So if the dpmi client called
    a real-mode proc from inside the callback, it didn't get
    the true client real-mode segments. Don't know if this could
    be a problem, but other hosts don't behave this way, so it
    has been changed.
  þ some small changes to reduce size of binary

  22.06.2005, version 1.88

  þ bugfix: initialization errors caused garbage to be displayed
  þ bugfix: making HDPMI stay resident using both options -R + -L
    was hazardous
  þ default exception handler code partly rewritten so it becomes
    readable again.

  12.06.2005, version 1.87

  þ CR0 NE bit now is set as default. Makes command line option -n
    superfluous. New command line option -t will reset CR0 NE bit
    instead.
  þ execute FNINIT in default exception 10h handler. 
  þ bugfix: an int 10h handler may have been called as if an
    exception 10h had occured, that is, onto the locked stack.
              
  17.05.2005, version 1.86

  þ "mov reg,crX" is fully emulated now (opcode 0F 20 xx), except reg == ESP.              
  þ clear TS bit in CR0 on startup.
  þ translation of int 21h, ah=38h now documented

  14.05.2005, version 1.85

  þ bugfix: default exception handler may have ignored key strokes
  þ emulation of "mov eax,cr0" and "mov eax,cr2" reactivated

  13.12.2004, version 1.84

  þ translation for int 21h, ax=71A0h added
  þ exception 07 default handler now routes exception to protected
    mode int 07. It is not routed to real-mode, though.
  þ command line switches -d and -e added
  þ command line switch -l (=enviroment switch HDPMI=8) added
  þ dos memory functions now return error codes 8011h and 8022h
  þ dos memory alloc for 16-bit: selector tiling modified to
    exactly match dpmi specs
  þ internal: task state restored before server terminates

  01.12.2004, version 1.83

  þ switched to Digital Mars C++ linker to reduce size of HDPMI
  þ DR7 now cleared on client termination as specified in DPMI V1.0
  þ bugfix: special registers DR7 and CR0 are no longer accessed in
    V86 mode when HDPMI terminates (VCPI mode only).
  þ bugfix: a GPF occured if client exited int 23h with RETF
    instead of RETF 4
  þ CR0 MP flag now saved and restored as are EM + NE
  þ command line switch -n added
  þ locked protected mode stack selector now in LDT. Required
    by WIN87EM.DLL of windows 3.1 which tries to create a code
    alias for LPMS selector (found in Netscape 4.08).
  þ bugfix: int 15h mouse event proc had wrong stack parameters
  þ bugfix: int 33h mouse event proc caused GPF on RETF

  24.11.2004, version 1.82

  þ bugfix: TF was lost when save/restore task state was called in real mode
  þ translation for int 21h, ax=6521h, 6522h, 65A1h, 65A2h added
  þ translation for int 21h, ax=5D0Ah added (set ext error info)
  þ bugfix: exc 0D with EIP > limit(CS) caused an exc 0D in ring 0

  07.11.2004, version 1.81

  þ bugfix: int 21h, ax=440Dh, minor codes 40h,41h,61h did use
    ds:dx for 32bit clients, not ds:edx

  10.10.2004, version 1.80

  þ bugfix: address space allocation may not have worked in all
    cases if HDPMI was installed with option -r (resident)
  þ bugfix: pressing Ctrl-C during console read may have caused
    a fatal dos memory error (asw.exe).

  02.10.2004, version 1.79

  þ bugfix: function 0503h may have modified ES register

  25.09.2004, version 1.78

  þ new command line switch -m to disable DPMI 1.0 memory functions
  þ function 401h, AX now has WRITE-PROTECT CLIENT bit set.
  þ bugfix: function 0401h modified E/DI.

  17.09.2004, version 1.77

  þ API translation for int 21h, ax=71A6 added (LFN version only)
  þ bugfix: there was still a problem with releasing XMS memory,
    though it worked better than in v1.75

  12.09.2004, version 1.76

  þ bugfix: HDPMI v1.75 crashed on exit if more than 1 XMS handle
    had to be released. 

  11.09.2004, version 1.75

  þ bugfix: int 23h/24h traps did work for 1. client only 
  þ command line switches -r and -u added, to install/uninstall
    HDPMI as a TSR.
  þ bugfix: int 31h, ax=507h may have caused memory leaks
  þ DOS API translation AX=6300 added (get DBCS table)

  29.08.2004, version 1.74

  þ unsupported version with LFN API translation released

  10.06.2004, version 1.73

  þ client CS:EIP stored on top of locked protected-mode stack
  þ HLT now executed, not simulated

  05.06.2004, version 1.72

  þ bugfix: int 21h, ah=49h: if memory to free was in conv. memory,
    ES may have been released even if dos function failed.
  þ function 0503h no longer fails if a block which contains
    uncommitted pages has to be moved
  þ bugfix: function 0503h (resize memory) has lost HIWORD
    of EBX in some cases.
  þ bugfix: exception 01 handler wasn't called if TF wasn't set,
    i.e. cleared by an IRET. INT 01 handler was called in any case.
  þ bugfix: redirection IRQs from real-mode to protected-mode
    didn't work properly
  þ bugfix: dos api translation AH=65h, AL>0 now works
  þ terminating client after an exception now uses LPMS
  þ waiting for a keystroke after exception dump now works better
  þ bugfix: failure of phys address mapping didn't set carry flag

  12.05.2004, version 1.71

  þ bugfix: HDPMI v1.70 didn't work with VCPI!
  þ bugfix: TLB cache is now cleared after system tables have
    been moved high. Because of this bug HDPMI versions 1.62-1.70 
    may not run in non-VCPI modes on 80486 and 80586 cpus.
  þ (re)set real-mode DTA when client calls int 21h, ah=1ah

  10.05.2004, version 1.70

  þ bugfix: reset DTA after int 21h, ax=4b00h
  þ bugfix: int 31h, ax=0002 sometimes didn't recognize
    an already returned selector for a real-mode segment
  þ bugfix: environment for 16-bit clients in int 21h, ax=4b00h
    exec parameter block now used if != 0
  þ count of raw switches deleted
  þ if trace flag set on raw mode switch to protected mode,
    now halt on first instruction, not the second one
  þ bugfix: when a client other than the first one terminated,
    int 21h, ah=4ch was called with host stack, which could cause
    problems in some circumstances.
  þ API translation support for int 33h, ax=0009h,ax=0016h,ax=0017h
  þ bugfix: restrict DOS AH=0Ch API translation to subfunction 0Ah 
  þ bugfix: tool DPMIRS16 didn't load HDPMI16.EXE 
  þ switch HDPMI=4 added (return V1.0 server version)

  10.04.2004, version 1.67

  þ now int 15h in real mode is modified in raw mode only
  þ function 0505h (resize linear memory block) added
  þ set CR4 OSXMM flag (200h) on server entry

  18.03.2004, version 1.66

  þ understands vendor "VIRTUAL SUPPORT" for 32RTM.EXE support
  þ emulate 'mov eax,crx' and 'mov crx, eax'
  þ bugfix: int 31, ah=507h was unable to commit a page
  þ bugfix: int 2f, ax=168ah, vendor MS-DOS, returned function
    address for 32bit didnt clear HIWORD(edi)
  þ bugfix: int 31, ax=506h didnt return read/write attribute
  þ bugfix: int 21, ah=00h wrongly expected current PSP in bx

  29.02.2004, version 1.65

  þ bugfix: int 31, ax=604h returned a wrong page size

  24.01.2004, version 1.64
 
  þ int 21, ah=71h (LFN) no longer routed to DOS if LFN translation
    service deactivated (which is default)
  þ bugfix: linear address returned by function 0800h had always bits
    0-11 zeroed
  þ functions 0600h/0601h now return C if memory region is invalid
    (not allocated) 

  05.01.2004, version 1.63

  þ in psp kill function (int 21, ah=0) the psb isn't touched
    any more after real mode dos call returned
  þ translation support for long filenames (AH=71h), optional
  þ bug fixed for translation of int 21h, AX=7305h

  29.12.2003, version 1.62

  þ now pagedir in sysarea 0, user addr space now 4088 MB
  þ bugfixes for AllocSpecAddrSpace + FreeMem
  þ page tables now mapped in last page table, thus
    increasing user address space to 4084 MB (really)
  þ DPMI 1.0 function 0801h (unmap phys region) impl.
    max mem block in func 0500 now limited to largest free
    addr space region.

  21.12.2003, version 1.61

  þ DPMI 1.0 functions 0401h (get capabilities), 0504h
    (uncommitted memory) and 0507h (set page attributes)
    implemented.
  þ HDPMI environment variable read before real mode initialization

  11.12.2003, version 1.56

  þ release part of int15 memory if an app is launched.
    this allows multiple instances of HDPMI in int15 mode.
  þ HDPMI properly terminates if initialization fails (low memory)
  þ As default DOS memory is no longer in memory pool
  þ no more FFFF pages limit for memory allocation
  þ check es, fs, gs if a selector is freed by int31, ax=1
  þ pressing ctrl-alt-del now executes int21, ax=4c00
  þ exceptions in ring0 will now stop in kernel debugger
  þ DPMI 1.0 function 0506h (get page attributes) impl.
  þ int 3 in ring 0 is ignored now
  þ bugfix: scan for HDPMI looped if another var beginning
    with H occured in environment
  þ now using current environment block for int 21h, 4b00h
  þ total/free address space now handled correctly.
    no crash anymore if server runs out of address space
  þ bugfix: map physical memory was limited to FFFF pages,
    but returned no error otherwise.

  30.11.2003, version 1.55

  þ use int 15h, ax=e801h to get extended memory > 64 MB

  27.11.2003, version 1.54

  þ new switch HDPMI=4 restricts reporting of available
    memory to max. block size for I31, ax=0500h
  þ bugfix: a 8 kB memory block wasn't released if a task
    other than the first one has terminated.
  þ bugfix: for exceptions in ring 0 pressing (c)lient didn't work

  24.11.2003, version 1.53

  þ kernel debugger is now called for ring 0 exceptions as well

  20.05.2003, version 1.52

  þ kernel debug support wasn't activated in release version

  17.05.2002, version 1.51

  þ bugfix: reallocate memory (I31, AX=502h) didn't work in all cases
  þ memory handle is equal to base address for memory allocations
  þ system area moved to ff800000h, leaving 4084 MB for client
  þ some enhancements for kernel debugger support
  þ environment variable HDPMI implemented
  þ bugfix: wrong query for XMS host 3.0
    bugfix: memory request for 0 bytes will fail now
  þ i31swt: reset trace flag (call rm int)
  þ bug fixed in a20 server (xms gate 20 status)

  28.08.1999, version 1.50

  þ support of FAT32 API translation (Int21,AX=73xx)

  08.01.1998, version 1.40

  þ support for kernel debugger
  þ server now is in .EXE fromat (formerly .OVL)
  þ INT 96h in real mode to prevent debuggers stepping
    into server code.
  þ guard page 0 for IVT modifications
  þ temporary 64kb TLB for int 21 3F/40
  þ save/restore RMS now handled correctly

  14.05.1996, version 1.30

  þ reset NT-Flag in raw mode switch
  þ reset NT-Flag in real mode callbacks
  þ fixed bug in stack manipulation
  þ real mode int21 is saved and restored on exit
  þ for exception exit send EOI to kbd if necessary
  þ restore PM register for real-mode callbacks
  þ recognize 586 cpu
  þ recognize 486 cpu

  06.11.1994, version 1.20

  þ IRQs occuring in real mode now routed to protected mode

  06.06.1994, version 1.10

  þ many changes, clients now run in ring 3

  01.10.1993, version 1.00

  þ clients running in ring 0


 11. Copyright

   HDPMI is part of HX DOS extender runtime, which is freeware. It may be
   used for any purpose. Copyright Japheth 1993-2009.

   mail: mail@japheth.de
   web: http://www.japheth.de

